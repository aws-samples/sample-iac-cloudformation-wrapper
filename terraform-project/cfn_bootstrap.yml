---
AWSTemplateFormatVersion: "2010-09-09"

Description: |-
  Quick-start CloudFormation template to deploy the Terraform-based infrastructure sample via AWS
  CodeBuild - with no local developer setup required.

  This stack sets up an AWS CodeBuild Project to deploy the main solution and triggers the build
  once (via AWS Lambda) on stack create, plus again whenever the CodeBuildTrigger resource is
  updated. On deletion, it triggers another CodeBuild job to attempt to destroy the resources.
  Grants broad permissions to CodeBuild - not recommended for use in production environments.

Parameters:
  ExampleVisibilityTimeout:
    Type: Number
    MaxValue: 43200
    MinValue: 0
    Default: 300
    Description: >-
      Example solution parameter exposed to CloudFormation: Visibility time-out of the SQS queue in
      seconds. Must be a whole number.

  CodeRepo:
    Type: String
    Default: https://github.com/aws-samples/sample-iac-cloudformation-wrapper
    Description: >-
      The Terraform code to be deployed: A git clone-able URL, public .zip archive URL, or s3://
      URI to a zip archive. NOTE: For security, only deploy code from trusted sources.

  CodeRepoBranch:
    Type: String
    Default: main
    Description: >-
      Branch (or commit hash) of the repository to deploy from. Ignored if CodeRepo is not a git URL
  
  CodeRepoFolder:
    Type: String
    Default: terraform-project
    Description: >-
      Subfolder in the repository containing the deployable Terraform project. Leading slash
      optional. Set '/' (not empty) for root folder.

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Solution Settings
        Parameters:
          - ExampleVisibilityTimeout
      - Label:
          default: Source Code Location
        Parameters:
          - CodeRepo
          - CodeRepoBranch
          - CodeRepoFolder

Resources:

  TFStateBucket:
    Type: "AWS::S3::Bucket"
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled

  # CloudFormation will fail to delete TFStateBucket on stack delete unless it's been emptied out,
  # so we need to set up a custom resource Lambda to empty the bucket on delete:
  TFStateCleanUpExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole' # (CloudWatch Logs)
      Policies:
        - PolicyName: EmptyTFStateBucket
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: BucketPerms
                Effect: Allow
                Action:
                  - "s3:GetBucketVersioning"
                  - "s3:ListBucket"
                  - "s3:ListBucketMultipartUploads"
                  - "s3:ListBucketVersions"
                Resource:
                  - !GetAtt TFStateBucket.Arn
              - Sid: ObjectPerms
                Effect: Allow
                Action:
                  - "s3:AbortMultipartUpload"
                  - "s3:DeleteObject"
                  - "s3:DeleteObjectVersion"
                Resource:
                  - !Sub "${TFStateBucket.Arn}/*"

  TFStateCleanUpFunction:
    Type: "AWS::Lambda::Function"
    # checkov:skip=CKV_AWS_115:See cfn_nag W92
    # checkov:skip=CKV_AWS_116:Synchronous Lambda has no need for DLQ
    # checkov:skip=CKV_AWS_117:See cfn_nag W89
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "IAM will authorize access to this rarely-used function: No need to put in VPC"
          - id: W92
            reason: "Only to be invoked by CREATE/UPDATE/DELETE CFN events for this stack: no reserved concurrency required"
    Properties:
      Description: "CloudFormation custom resource emptying an S3 bucket ready for deletion"
      Code:
        ZipFile: |
          # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
          """Custom CloudFormation Resource to empty an S3 bucket on deletion

          CFn Properties
          --------------
          BucketName : string
              Name of the S3 bucket to empty
          """

          # Python Built-Ins:
          import logging
          import traceback

          # External Dependencies:
          import boto3
          import cfnresponse

          s3 = boto3.resource("s3")

          def lambda_handler(event, context):
              try:
                  request_type = event["RequestType"]
                  if request_type == "Create":
                      handle_upsert(event, context)
                  elif request_type == "Update":
                      handle_upsert(event, context)
                  elif request_type == "Delete":
                      handle_delete(event, context)
                  else:
                      cfnresponse.send(
                          event,
                          context,
                          cfnresponse.FAILED,
                          {},
                          reason=f"Unsupported CFN RequestType '{request_type}'",
                      )
              except Exception as e:
                  logging.error("Uncaught exception in CFN custom resource handler - reporting failure")
                  traceback.print_exc()
                  cfnresponse.send(
                      event,
                      context,
                      cfnresponse.FAILED,
                      {},
                      reason=f"See CloudWatch {context.log_group_name} > {context.log_stream_name} - {str(e)}",
                  )
                  raise e

          def handle_upsert(event, context) -> None:
              logging.info("**Received create/update event")
              # Validate the new BucketName and fail if necessary:
              res_config = event.get("ResourceProperties", {})
              bucket_name = res_config.get("BucketName")
              if not isinstance(bucket_name, str):
                  cfnresponse.send(
                      event,
                      context,
                      cfnresponse.FAILED,
                      {
                          "Reason": (
                              f"'BucketName' property must be a string (S3 bucket name). Got: {bucket_name}"
                          ),
                      },
                      physicalResourceId=event["PhysicalResourceId"],
                  )
                  return

              # If an update request returns a different physical ID, CloudFormation will raise a delete
              # event for the old one. Using the BucketName as our physical ID would correctly handle updates
              # to change the underlying AWS::S3::Bucket's BucketName in the stack, because that change
              # requires bucket replacement and this custom resource would empty the old bucket. However, we
              # instead always propagate the original physical ID because this provides less destructive
              # options in case the user *wants* to disengage this custom resource from their bucket without
              # emptying the data:
              cfnresponse.send(
                  event,
                  context,
                  cfnresponse.SUCCESS,
                  { "Reason": "Create/update is a no-op" },
                  physicalResourceId=event.get(
                      "PhysicalResourceId",
                      "/".join((event.get("StackId"), event.get("RequestId")))
                  ),
              )

          def handle_delete(event, context) -> None:
              logging.info("**Received delete event")
              res_config = event.get("ResourceProperties", {})
              bucket_name = res_config.get("BucketName")
              if not isinstance(bucket_name, str):
                  cfnresponse.send(
                      event,
                      context,
                      cfnresponse.FAILED,
                      { "Reason": "Required 'BucketName' property not set" },
                      physicalResourceId=event["PhysicalResourceId"],
                  )
                  return
              if not bucket_name:  # Escape hatch to detach without cleaning bucket
                  cfnresponse.send(
                      event,
                      context,
                      cfnresponse.SUCCESS,
                      { "Reason": "Ignoring explicitly empty '' BucketName" },
                      physicalResourceId=event["PhysicalResourceId"],
                  )
                  return

              bucket = s3.Bucket(bucket_name)
              bucket_versioning = s3.BucketVersioning(bucket_name)
              for upload in bucket.multipart_uploads.all():
                  upload.abort()
              if bucket_versioning.status == "Enabled":
                  bucket.object_versions.delete()
              else:
                  bucket.objects.delete()

              cfnresponse.send(
                  event,
                  context,
                  cfnresponse.SUCCESS,
                  { "Reason": f"Deleted all objects from bucket {bucket_name}" },
                  physicalResourceId=event["PhysicalResourceId"],
              )

      Handler: "index.lambda_handler"
      MemorySize: 128
      Role: !GetAtt TFStateCleanUpExecutionRole.Arn
      Runtime: python3.13
      Timeout: 900

  EmptyTFStateBucketOnDelete:
    Type: "Custom::EmptyS3BucketOnDelete"
    Properties:
      ServiceToken: !GetAtt TFStateCleanUpFunction.Arn
      BucketName: !Ref TFStateBucket

  CodeBuildServiceRole:
    Type: "AWS::IAM::Role"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "Not recommended for use in production environments: Grants CodeBuild broad access to deploy/destroy the solution without scoping down individual required services & resources"
          - id: W44
            reason: "Not recommended for use in production environments: Grants CodeBuild broad access to deploy/destroy the solution without scoping down individual required services & resources"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: SampleDeploymentPermissions
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # You almost certainly want to see logs in case the deployment goes wrong...
              - Sid: CloudWatchLogs
                Effect: Allow
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource:
                  - !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/*"
                  - !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/codebuild/*:*"
              - Sid: TFStateBucketList
                Effect: Allow
                Action:
                  - "s3:ListBucket"
                Resource:
                  - !GetAtt TFStateBucket.Arn
              # Could consider scoping down further if your TF backend key will always be same or
              # fall under a known path. For more details on required state bucket permissions, see
              # https://developer.hashicorp.com/terraform/language/backend/s3#permissions-required
              - Sid: TFStateBucketAccess
                Effect: Allow
                Action:
                  - "s3:DeleteObject"
                  - "s3:GetObject"
                  - "s3:PutObject"
                Resource:
                  - !Sub "${TFStateBucket.Arn}/*"
              # Our example app just provisions an SQS Queue:
              - Sid: SQS
                Effect: Allow
                Action:
                  - "sqs:AddPermission"
                  - "sqs:CreateQueue"
                  - "sqs:DeleteQueue"
                  - "sqs:GetQueueAttributes"
                  - "sqs:ListQueues"
                  - "sqs:ListQueueTags"
                  - "sqs:RemovePermission"
                  - "sqs:TagQueue"
                  - "sqs:UntagQueue"
                Resource:
                  - !Sub "arn:${AWS::Partition}:sqs:${AWS::Region}:${AWS::AccountId}:*"
      #### While generous permissions like the commented-out managed policy below might be useful
      #### for initial debugging of apps that touch many services, best-practice is to scope down
      #### to just the access required to bootstrap and deploy the particular solution:
      # ManagedPolicyArns:
      #   - "arn:aws:iam::aws:policy/PowerUserAccess"

  CodeBuildProject:
    Type: "AWS::CodeBuild::Project"
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W32
            reason: "Use default S3 encryption - no actual artifacts being created"
    Properties:
      Artifacts:
        Type: NO_ARTIFACTS
      ConcurrentBuildLimit: 1
      Description: "Terraform deployer"
      Environment:
        ComputeType: BUILD_GENERAL1_LARGE
        EnvironmentVariables:
          # Pass through CloudFormation parameters to TF deploy job
          # Code fetch parameters:
          - Name: PUBLIC_REPO
            Type: PLAINTEXT
            Value: !Ref CodeRepo
          - Name: PUBLIC_REPO_BRANCH
            Type: PLAINTEXT
            Value: !Ref CodeRepoBranch
          - Name: PUBLIC_REPO_FOLDER
            Type: PLAINTEXT
            Value: !Ref CodeRepoFolder
          # Terraform backend:
          - Name: TF_STATE_BUCKET
            Value: !Ref TFStateBucket
          # Solution parameters:
          - Name: TF_VAR_queue_visibility_timeout
            Type: PLAINTEXT
            Value: !Ref ExampleVisibilityTimeout
        Image: "aws/codebuild/standard:7.0"
        ImagePullCredentialsType: CODEBUILD
        PrivilegedMode: true # Need to build container images within the project
        Type: LINUX_CONTAINER
      QueuedTimeoutInMinutes: 80
      ServiceRole: !GetAtt CodeBuildServiceRole.Arn
      Source:
        BuildSpec: |
          version: 0.2
          env:
            shell: bash
          phases:
            install:
              commands:
                - wget --no-verbose https://releases.hashicorp.com/terraform/1.12.2/terraform_1.12.2_linux_amd64.zip
                - unzip terraform_1.12.2_linux_amd64.zip
                - mv terraform /usr/local/bin/
            pre_build:
              commands:
                - set -ex
                # Up-front install to fail early (but we reinst later in case it's overwritten):
                - pip3 install "requests>=2.27,<3"
            build:
              commands:
                - set -ex
                # Fetch the source code via either S3 CLI, curl (if PUBLIC_REPO ends with '.zip')
                # or else git:
                - |
                  case "$PUBLIC_REPO" in
                    s3://*)
                      aws s3 cp "$PUBLIC_REPO" code.zip && unzip -oq code.zip -d code
                      export PUBLIC_REPO_IS_ARCHIVE=true
                      ;;
                    *.zip)
                      curl "$PUBLIC_REPO" -o code.zip && unzip -oq code.zip -d code
                      export PUBLIC_REPO_IS_ARCHIVE=true
                      ;;
                    *)
                      git clone --single-branch -b $PUBLIC_REPO_BRANCH --depth 1 $PUBLIC_REPO code
                      export PUBLIC_REPO_IS_ARCHIVE=false
                      ;;
                  esac
                - cd code
                # Handle potential folder nesting if source code was extracted from a zip/archive:
                - |
                  if [ "$PUBLIC_REPO_IS_ARCHIVE" = "true" ]; then
                    N_EXTRACTED_SUBFOLDERS="$(find . -type d -mindepth 1 -maxdepth 1 | wc -l)"
                    N_EXTRACTED_SUBFILES="$(find . -type f -mindepth 1 -maxdepth 1 | wc -l)"
                    if [ \( $N_EXTRACTED_SUBFOLDERS -eq "1" \) -a \( $N_EXTRACTED_SUBFILES -eq "0" \) ]; then
                      echo "Zip extracted one top-level folder. Treating that as code root"
                      cd "$(ls -d */|head -n 1)"
                    fi
                  fi
                # Move to the subfolder if needed
                # ('#/' parameter expansion ignores leading slash if present)
                - cd "./${PUBLIC_REPO_FOLDER#/}" && pwd
                # Actual deploy/destroy instructions for this repository:
                - terraform init -backend-config "bucket=$TF_STATE_BUCKET"
                - if [ "$CFN_EVENT_TYPE" = "Delete" ]; then terraform destroy -auto-approve -input=false; else terraform apply -auto-approve -input=false; fi
                - terraform output -json > tf.outputs.json
              finally:
                # Re-install requests in case it got overwritten:
                - pip3 install "requests>=2.27,<3"
                - |
                  cat <<EOS | python3 -
                  import json
                  import os
                  import requests  # (You'll need to install this!)
                  resp_url = os.environ.get("CFN_EVENT_RESPONSE_URL")

                  def prep_outputs(d: dict):
                      """Simplify Terraform outputs JSON into CloudFormation attributes dict"""
                      return {
                          k: v["value"]
                          for k, v in d.items()
                          if not (v.get("value") is None or v.get("sensitive"))
                      }

                  if not resp_url:
                      print("No CloudFormation response URL provided")
                      exit(0)
                  try:
                      data = json.loads(os.environ["CFN_EVENT_DATA"])
                      if int(os.environ["CODEBUILD_BUILD_SUCCEEDING"]):
                          data["Status"] = "SUCCESS"
                          try:
                              # Pass Terraform deploy outputs as attributes of this CFn resource:
                              with open("tf.outputs.json") as fouts:
                                  outputs = json.load(fouts)
                                  data["Data"] = prep_outputs(outputs)
                          except FileNotFoundError:
                              print(
                                  "No tf.outputs.json found: Have your deploy job create this "
                                  "file if you want to pass outputs back to the bootstrap stack."
                              )
                      else:
                          data["Status"] = "FAILED"
                      build_arn = os.environ["CODEBUILD_BUILD_ARN"]
                      data["Reason"] = "See details in CloudWatch Log Stream /aws/codebuild/" + (
                          build_arn.partition("/")[2]
                      )
                      response = requests.put(resp_url, data=json.dumps(data))
                      print(f"Notified CloudFormation of {data['Status']}")
                  except Exception as e:
                      print(f"Failed to send response to CloudFormation event handler")
                      raise e
                  EOS
        SourceIdentifier: coderepo
        Type: NO_SOURCE
      TimeoutInMinutes: 60

  # Creating a CodeBuild project in CloudFormation doesn't automatically start a build, so below we
  # set up an AWS Lambda Function based Custom Resource to trigger the build whenever the stack is
  # created or updated:

  CodeBuildTriggerExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole' # (CloudWatch Logs)
      Policies:
        - PolicyName: RunCodeBuildProject
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: RunCodeBuild
                Effect: Allow
                Action:
                  - "codebuild:StartBuild"
                Resource:
                  - !GetAtt CodeBuildProject.Arn

  CodeBuildTriggerFunction:
    Type: "AWS::Lambda::Function"
    # checkov:skip=CKV_AWS_115:See cfn_nag W92
    # checkov:skip=CKV_AWS_116:Synchronous Lambda has no need for DLQ
    # checkov:skip=CKV_AWS_117:See cfn_nag W89
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "IAM will authorize access to this rarely-used function: No need to put in VPC"
          - id: W92
            reason: "Only to be invoked by CREATE/UPDATE/DELETE CFN events for this stack: no reserved concurrency required"
    Properties:
      Description: "CloudFormation custom resource implementation for running CodeBuild project"
      Code:
        ZipFile: |
          # Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
          """Custom CloudFormation Resource to kick off CodeBuild project builds

          CFn Properties
          --------------
          ProjectName : string
              Name of the AWS CodeBuild project to run
          BuildOnDelete : Optional[bool]
              Set `True` to also run a build on CloudFormation `Delete` events (i.e. if your CodeBuild
              script will detect that `CFN_EVENT_TYPE` is `Delete` and destroy its resources)
          CodeBuildCallback : Optional[bool]
              Set `True` if your CodeBuild project will handle the CloudFormation CR callback, or leave
              default (False) to report success as soon as the build is triggered.
          IgnoreUpdate : Optional[bool]
              Set `True` to only trigger a build on initial `Create` events and ignore subsequent `Update`s

          CodeBuild Env Var Overrides
          ---------------------------
          CFN_EVENT_TYPE : Union["Create", "Update", "Delete"]
              Type of CloudFormation event that triggered the build
          CFN_EVENT_DATA : str
              JSON object containing LogicalResourceId, RequestId, StackId, NoEcho, and (empty) Data that
              your CodeBuild should post back to CloudFormation on completion/failure (when provided). Note
              your build project will need to add the `Status`, `Reason`, and `PhysicalResourceId` fields.
          CFN_EVENT_RESPONSE_URL : str
              URL to which the CloudFormation response data should be `PUT` (if provided)
          """

          # Python Built-Ins:
          import json
          import logging
          import traceback

          # External Dependencies:
          import boto3
          import cfnresponse

          codebuild = boto3.client("codebuild")

          def lambda_handler(event, context):
              try:
                  request_type = event["RequestType"]
                  if request_type == "Create":
                      handle_create(event, context)
                  elif request_type == "Update":
                      handle_update(event, context)
                  elif request_type == "Delete":
                      handle_delete(event, context)
                  else:
                      cfnresponse.send(
                          event,
                          context,
                          cfnresponse.FAILED,
                          {},
                          reason=f"Unsupported CFN RequestType '{request_type}'",
                      )
              except Exception as e:
                  logging.error("Uncaught exception in CFN custom resource handler - reporting failure")
                  traceback.print_exc()
                  cfnresponse.send(
                      event,
                      context,
                      cfnresponse.FAILED,
                      {},
                      reason=f"See CloudWatch {context.log_group_name} > {context.log_stream_name} - {str(e)}",
                  )
                  raise e


          def get_cfn_env_var_overrides(event):
              res_config = event.get("ResourceProperties", {})
              result = [
                  {"name": "CFN_EVENT_TYPE", "type": "PLAINTEXT", "value": event["RequestType"]},
              ]
              if res_config.get("CodeBuildCallback"):
                  result += [
                      {
                          "name": "CFN_EVENT_DATA",
                          "type": "PLAINTEXT",
                          "value": json.dumps({
                              "LogicalResourceId": event["LogicalResourceId"],
                              "PhysicalResourceId": event["LogicalResourceId"],
                              "RequestId": event["RequestId"],
                              "StackId": event["StackId"],
                              "NoEcho": event["ResourceProperties"].get("NoEcho", False),
                              "Data": {},
                          }),
                      },
                      {
                          "name": "CFN_EVENT_RESPONSE_URL",
                          "type": "PLAINTEXT",
                          "value": event["ResponseURL"],
                      },
                  ]
              return result


          def handle_create(event, context):
              logging.info("**Received create request - running CodeBuild job")
              res_config = event["ResourceProperties"]
              codebuild_env_vars = get_cfn_env_var_overrides(event)
              result = codebuild.start_build(
                  projectName=res_config["ProjectName"],
                  environmentVariablesOverride=codebuild_env_vars,
              )
              if not res_config.get("CodeBuildCallback"):
                  cfnresponse.send(
                      event,
                      context,
                      cfnresponse.SUCCESS,
                      { "Reason": f"Started CodeBuild #{result['build']['buildNumber']}" },
                      # Changing physical ID would look like a 'replacement' to CloudFormation,
                      # causing it to send a delete/destroy request to the old physical ID after
                      # running terraform apply on the new one - which is pretty much never what we
                      # want.
                      physicalResourceId=event["LogicalResourceId"],
                  )

          def handle_delete(event, context):
              logging.info("**Received delete event - no-op")
              res_config = event.get("ResourceProperties", {})
              build_on_delete = res_config.get("BuildOnDelete", False)
              if build_on_delete:
                  codebuild_env_vars = get_cfn_env_var_overrides(event)
                  codebuild.start_build(
                      projectName=res_config["ProjectName"],
                      environmentVariablesOverride=codebuild_env_vars,
                  )
                  reason = "Deletion build initiated"
              else:
                  reason = "Delete is a no-op"
              if not (build_on_delete and res_config.get("CodeBuildCallback")):
                  cfnresponse.send(
                      event,
                      context,
                      cfnresponse.SUCCESS,
                      { "Reason": reason },
                      physicalResourceId=event["PhysicalResourceId"],
                  )

          def handle_update(event, context):
              logging.info("**Received update event - re-running build")
              res_config = event.get("ResourceProperties", {})
              ignore_update = res_config.get("IgnoreUpdate", False)
              if ignore_update:
                  reason = "Update is a no-op"
              else:
                  codebuild_env_vars = get_cfn_env_var_overrides(event)
                  result = codebuild.start_build(
                      projectName=res_config["ProjectName"],
                      environmentVariablesOverride=codebuild_env_vars,
                  )
                  if res_config.get("CodeBuildCalback"):
                      reason = None
                  else:
                      reason = f"Started CodeBuild #{result['build']['buildNumber']}"
              if reason is not None:
                  cfnresponse.send(
                      event,
                      context,
                      cfnresponse.SUCCESS,
                      { "Reason": reason },
                      physicalResourceId=event["PhysicalResourceId"],
                  )

      Handler: "index.lambda_handler"
      MemorySize: 128
      Role: !GetAtt CodeBuildTriggerExecutionRole.Arn
      Runtime: python3.13
      Timeout: 900

  # IF you enable CodeBuildCallback AND your deployment script creates 'tf.outputs.json', the
  # contents should be passed through as output attributes on this CFn resource to use how you want
  # For example, re-exposing them as outputs of this CFn bootstrap stack) with a reference like:
  #     !GetAtt SampleDeployment.SomeOutput
  SampleDeployment:
    Type: "Custom::CodeBuildTrigger"
    DependsOn:
      - EmptyTFStateBucketOnDelete  # Don't clear out TF state bucket til `terraform destroy` done
    Properties:
      ServiceToken: !GetAtt CodeBuildTriggerFunction.Arn
      ProjectName: !Ref CodeBuildProject
      BuildOnDelete: true
      # NOTE: If deployment takes longer than 1 hour, this CodeBuild-based callback to
      # CloudFormation *will not work* because CFn will time out. In that case can comment out /
      # unset `CodeBuildCallback`, and the bootstrap stack will "succeed" as soon as the CodeBuild
      # job is triggered, without waiting for it to complete.
      CodeBuildCallback: true

Outputs:
  CodeBuildProjectArn:
    Description: ARN of the AWS CodeBuild project created to deploy the solution
    Value: !GetAtt CodeBuildProject.Arn
  CodeBuildProjectName:
    Description: Name of the AWS CodeBuild project created to deploy the solution
    Value: !Ref CodeBuildProject
  CodeBuildConsoleLink:
    Description: Link to project in AWS CodeBuild Console
    Value: !Sub "https://${AWS::Region}.console.aws.amazon.com/codesuite/codebuild/${AWS::AccountId}/projects/${CodeBuildProject}"
  ExampleQueueArn:
    Description: Example re-published CDK output - ARN of the created SQS Queue
    Value: !GetAtt SampleDeployment.QueueArn
